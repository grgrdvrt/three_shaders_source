<!doctype html>
<html>
    <head>
        <title>meshbasic</title>
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"
        />
        <link rel="stylesheet" href="./style.css" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/glsl.min.js"></script>

        <script>
            hljs.highlightAll();
        </script>

        <!-- define symbol in hidden svg document -->
        <svg style="display: none" version="2.0">
            <defs>
                <symbol id="code" viewBox="0 -960 960 960">
                    <path
                        d="M320-240 80-480l240-240 57 57-184 184 183 183-56 56Zm320 0-57-57 184-184-183-183 56-56 240 240-240 240Z"
                    />
                </symbol>
                <symbol id="code_off" viewBox="0 -960 960 960">
                    <path
                        d="M791-55 280-566l-87 87 183 183-56 56L80-480l143-143L55-791l57-57 736 736-57 57Zm-54-282-57-57 87-87-183-183 56-56 240 240-143 143Z"
                    />
                </symbol>
            </defs>
            <!-- to make the circle-arrow-left.svg file
               also usable as image: -->
            <use href="#circle-arrow-left" />
        </svg>
    </head>
    <body>
        <nav>
    <a class="indexLink"
    href="./index.html"
        ><svg
            xmlns="http://www.w3.org/2000/svg"
            height="24px"
            viewBox="0 -960 960 960"
            width="24px"
            fill="currentColor"
        >
            <path
                d="M240-200h120v-240h240v240h120v-360L480-740 240-560v360Zm-80 80v-480l320-240 320 240v480H520v-240h-80v240H160Zm320-350Z"
            /></svg
    ></a>
    <ul>
    <li
      
      ><a href="./background.html">background</a></li><li
      
      ><a href="./backgroundCube.html">backgroundCube</a></li><li
      
      ><a href="./cube.html">cube</a></li><li
      
      ><a href="./depth.html">depth</a></li><li
      
      ><a href="./distanceRGBA.html">distanceRGBA</a></li><li
      
      ><a href="./equirect.html">equirect</a></li><li
      
      ><a href="./linedashed.html">linedashed</a></li><li
      class="selected"
      ><a href="./meshbasic.html">meshbasic</a></li><li
      
      ><a href="./meshlambert.html">meshlambert</a></li><li
      
      ><a href="./meshmatcap.html">meshmatcap</a></li><li
      
      ><a href="./meshnormal.html">meshnormal</a></li><li
      
      ><a href="./meshphong.html">meshphong</a></li><li
      
      ><a href="./meshphysical.html">meshphysical</a></li><li
      
      ><a href="./meshtoon.html">meshtoon</a></li><li
      
      ><a href="./points.html">points</a></li><li
      
      ><a href="./shadow.html">shadow</a></li><li
      
      ><a href="./sprite.html">sprite</a></li><li
      
      ><a href="./vsm.html">vsm</a></li>
    </ul>
    <a
    class="otherChunksLink"
    href="./otherChunks.html">Other Chunks</a>
  </nav></nav>
        <article>
            <h1>meshbasic.glsl.js</h1>
            <section class="shader">
                <h2 title="expand all">
                    Vertex Shader
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        height="15px"
                        width="15px"
                        fill="#5f6368"
                    >
                        <use class="expand" href="#code" />
                        <use class="collapse hide" href="#code_off" />
                    </svg>
                </h2>
                <div class="code">
                    <pre><code class="language-glsl">
</code></pre><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;common&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;common&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// &lt;tonemapping_pars_fragment&gt; may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }

// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {

	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );

	return fract( sin( sn ) * c );

}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

#ifdef USE_ALPHAHASH

	varying vec3 vPosition;

#endif

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}

vec3 BRDF_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick &#039;94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH &#039;13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated

float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick &#039;94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH &#039;13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;batching_pars_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;batching_pars_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif

	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {

		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );

	}

	float getIndirectIndex( const in int i ) {

		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );

	}

#endif

#ifdef USE_BATCHING_COLOR

	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {

		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;

	}

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;uv_pars_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;uv_pars_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;

#endif
#ifdef USE_MAP

	uniform mat3 mapTransform;
	varying vec2 vMapUv;

#endif
#ifdef USE_ALPHAMAP

	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;

#endif
#ifdef USE_DISPLACEMENTMAP

	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SPECULARMAP

	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;envmap_pars_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;envmap_pars_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;color_pars_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;color_pars_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )

	varying vec3 vColor;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;fog_pars_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;fog_pars_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_FOG

	varying float vFogDepth;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;morphtarget_pars_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;morphtarget_pars_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_MORPHTARGETS

	#ifndef USE_INSTANCING_MORPH

		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];

	#endif

	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;

	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {

		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;

		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );

	}

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;skinning_pars_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;skinning_pars_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	uniform highp sampler2D boneTexture;

	mat4 getBoneMatrix( const in float i ) {

		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );

		return mat4( v1, v2, v3, v4 );

	}

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;logdepthbuf_pars_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;logdepthbuf_pars_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_LOGDEPTHBUF

	varying float vFragDepth;
	varying float vIsPerspective;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;clipping_planes_pars_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;clipping_planes_pars_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if NUM_CLIPPING_PLANES &gt; 0

	varying vec3 vClipPosition;

#endif</code></pre>
    </div><pre><code class="language-glsl">

void main() {

	</code></pre><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;uv_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;uv_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	vUv = vec3( uv, 1 ).xy;

#endif
#ifdef USE_MAP

	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;

#endif
#ifdef USE_ALPHAMAP

	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_LIGHTMAP

	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_AOMAP

	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_BUMPMAP

	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_NORMALMAP

	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_DISPLACEMENTMAP

	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_EMISSIVEMAP

	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_METALNESSMAP

	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_ROUGHNESSMAP

	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_ANISOTROPYMAP

	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_CLEARCOATMAP

	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_IRIDESCENCEMAP

	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SHEEN_COLORMAP

	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SPECULARMAP

	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SPECULAR_COLORMAP

	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_TRANSMISSIONMAP

	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_THICKNESSMAP

	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;color_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;color_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if defined( USE_COLOR_ALPHA )

	vColor = vec4( 1.0 );

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )

	vColor = vec3( 1.0 );

#endif

#ifdef USE_COLOR

	vColor *= color;

#endif

#ifdef USE_INSTANCING_COLOR

	vColor.xyz *= instanceColor.xyz;

#endif

#ifdef USE_BATCHING_COLOR

	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );

	vColor.xyz *= batchingColor.xyz;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;morphinstance_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;morphinstance_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_INSTANCING_MORPH

	float morphTargetInfluences[ MORPHTARGETS_COUNT ];

	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;

	for ( int i = 0; i &lt; MORPHTARGETS_COUNT; i ++ ) {

		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;

	}
#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;morphcolor_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;morphcolor_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if defined( USE_MORPHCOLORS )

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	vColor *= morphTargetBaseInfluence;

	for ( int i = 0; i &lt; MORPHTARGETS_COUNT; i ++ ) {

		#if defined( USE_COLOR_ALPHA )

			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];

		#elif defined( USE_COLOR )

			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];

		#endif

	}

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;batching_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;batching_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif</code></pre>
    </div><pre><code class="language-glsl">

	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )

		</code></pre><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;beginnormal_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;beginnormal_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;morphnormal_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;morphnormal_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;

	for ( int i = 0; i &lt; MORPHTARGETS_COUNT; i ++ ) {

		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];

	}

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;skinbase_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;skinbase_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;skinnormal_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;skinnormal_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;defaultnormal_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;defaultnormal_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">
vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT

	vec3 transformedTangent = objectTangent;

#endif

#ifdef USE_BATCHING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;

	#ifdef USE_TANGENT

		transformedTangent = bm * transformedTangent;

	#endif

#endif

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;

	#ifdef USE_TANGENT

		transformedTangent = im * transformedTangent;

	#endif

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif</code></pre>
    </div><pre><code class="language-glsl">

	#endif

	</code></pre><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;begin_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;begin_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">vec3 transformed = vec3( position );

#ifdef USE_ALPHAHASH

	vPosition = vec3( position );

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;morphtarget_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;morphtarget_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;

	for ( int i = 0; i &lt; MORPHTARGETS_COUNT; i ++ ) {

		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];

	}

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;skinning_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;skinning_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;project_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;project_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_BATCHING

	mvPosition = batchingMatrix * mvPosition;

#endif

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;logdepthbuf_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;logdepthbuf_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_LOGDEPTHBUF

	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;clipping_planes_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;clipping_planes_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if NUM_CLIPPING_PLANES &gt; 0

	vClipPosition = - mvPosition.xyz;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;worldpos_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;worldpos_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS &gt; 0

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_BATCHING

		worldPosition = batchingMatrix * worldPosition;

	#endif

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;envmap_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;envmap_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;fog_vertex&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;fog_vertex&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_FOG

	vFogDepth = - mvPosition.z;

#endif</code></pre>
    </div><pre><code class="language-glsl">

}
</code></pre>
                </div>
            </section>
            <section class="shader">
                <h2 title="expand all">
                    Fragment Shader
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        height="15px"
                        width="15px"
                        fill="#5f6368"
                    >
                        <use class="expand" href="#code" />
                        <use class="collapse hide" href="#code_off" />
                    </svg>
                </h2>
                <div class="code">
                    <pre><code class="language-glsl">
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

</code></pre><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;common&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;common&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// &lt;tonemapping_pars_fragment&gt; may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }

// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {

	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );

	return fract( sin( sn ) * c );

}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

#ifdef USE_ALPHAHASH

	varying vec3 vPosition;

#endif

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}

vec3 BRDF_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick &#039;94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH &#039;13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated

float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick &#039;94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH &#039;13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;dithering_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;dithering_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift according to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;color_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;color_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR )

	varying vec3 vColor;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;uv_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;uv_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;

#endif
#ifdef USE_MAP

	varying vec2 vMapUv;

#endif
#ifdef USE_ALPHAMAP

	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	varying vec2 vNormalMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_SPECULARMAP

	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;map_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;map_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_MAP

	uniform sampler2D map;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;alphamap_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;alphamap_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;alphatest_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;alphatest_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;alphahash_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;alphahash_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_ALPHAHASH

	/**
	 * See: https://casual-effects.com/research/Wyman2017Hashed/index.html
	 */

	const float ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.

	float hash2D( vec2 value ) {

		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );

	}

	float hash3D( vec3 value ) {

		return hash2D( vec2( hash2D( value.xy ), value.z ) );

	}

	float getAlphaHashThreshold( vec3 position ) {

		// Find the discretized derivatives of our coordinates
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );

		// Find two nearest log-discretized noise scales
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);

		// Compute alpha thresholds at our two noise scales
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);

		// Factor to interpolate lerp with
		float lerpFactor = fract( log2( pixScale ) );

		// Interpolate alpha threshold from noise at two scales
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;

		// Pass into CDF to compute uniformly distrib threshold
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);

		// Find our final, uniformly distributed alpha threshold (ατ)
		float threshold = ( x &lt; ( 1.0 - a ) )
			? ( ( x &lt; a ) ? cases.x : cases.y )
			: cases.z;

		// Avoids ατ == 0. Could also do ατ =1-ατ
		return clamp( threshold , 1.0e-6, 1.0 );

	}

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;aomap_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;aomap_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;lightmap_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;lightmap_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;envmap_common_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;envmap_common_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;envmap_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;envmap_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;fog_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;fog_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float vFogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;specularmap_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;specularmap_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;logdepthbuf_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;logdepthbuf_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if defined( USE_LOGDEPTHBUF )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;clipping_planes_pars_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;clipping_planes_pars_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if NUM_CLIPPING_PLANES &gt; 0

	varying vec3 vClipPosition;

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif</code></pre>
    </div><pre><code class="language-glsl">

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	</code></pre><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;clipping_planes_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;clipping_planes_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if NUM_CLIPPING_PLANES &gt; 0

	vec4 plane;

	#ifdef ALPHA_TO_COVERAGE

		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;

		#pragma unroll_loop_start
		for ( int i = 0; i &lt; UNION_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );

			if ( clipOpacity == 0.0 ) discard;

		}
		#pragma unroll_loop_end

		#if UNION_CLIPPING_PLANES &lt; NUM_CLIPPING_PLANES

			float unionClipOpacity = 1.0;

			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i &lt; NUM_CLIPPING_PLANES; i ++ ) {

				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );

			}
			#pragma unroll_loop_end

			clipOpacity *= 1.0 - unionClipOpacity;

		#endif

		diffuseColor.a *= clipOpacity;

		if ( diffuseColor.a == 0.0 ) discard;

	#else

		#pragma unroll_loop_start
		for ( int i = 0; i &lt; UNION_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) &gt; plane.w ) discard;

		}
		#pragma unroll_loop_end

		#if UNION_CLIPPING_PLANES &lt; NUM_CLIPPING_PLANES

			bool clipped = true;

			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i &lt; NUM_CLIPPING_PLANES; i ++ ) {

				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) &gt; plane.w ) &amp;&amp; clipped;

			}
			#pragma unroll_loop_end

			if ( clipped ) discard;

		#endif

	#endif

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;logdepthbuf_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;logdepthbuf_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if defined( USE_LOGDEPTHBUF )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;map_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;map_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_MAP

	vec4 sampledDiffuseColor = texture2D( map, vMapUv );

	#ifdef DECODE_VIDEO_TEXTURE

		// use inline sRGB decode until browsers properly support SRGB8_ALPHA8 with video textures (#26516)

		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif

	diffuseColor *= sampledDiffuseColor;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;color_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;color_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if defined( USE_COLOR_ALPHA )

	diffuseColor *= vColor;

#elif defined( USE_COLOR )

	diffuseColor.rgb *= vColor;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;alphamap_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;alphamap_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;alphatest_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;alphatest_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_ALPHATEST

	#ifdef ALPHA_TO_COVERAGE

	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;

	#else

	if ( diffuseColor.a &lt; alphaTest ) discard;

	#endif

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;alphahash_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;alphahash_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_ALPHAHASH

	if ( diffuseColor.a &lt; getAlphaHashThreshold( vPosition ) ) discard;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;specularmap_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;specularmap_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif</code></pre>
    </div><pre><code class="language-glsl">

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	</code></pre><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;aomap_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;aomap_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif

	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif

	#if defined( USE_ENVMAP ) &amp;&amp; defined( STANDARD )

		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );

	#endif

#endif</code></pre>
    </div><pre><code class="language-glsl">

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	</code></pre><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;envmap_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;envmap_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;

		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;opaque_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;opaque_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif

#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif

gl_FragColor = vec4( outgoingLight, diffuseColor.a );</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;tonemapping_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;tonemapping_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;colorspace_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;colorspace_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">gl_FragColor = linearToOutputTexel( gl_FragColor );</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;fog_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;fog_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;premultiplied_alpha_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;premultiplied_alpha_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif</code></pre>
    </div><div class="chunk folded">
    <pre class="include include-folded"><code class="language-glsl">#include &lt;dithering_fragment&gt;</code></pre>
    <pre class="include include-opened"><code class="language-glsl">// &lt;dithering_fragment&gt;</code></pre>
    <pre class="src"><code class="language-glsl">#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif</code></pre>
    </div><pre><code class="language-glsl">

}
</code></pre>
                </div>
            </section>
        </article>
        <script src="./script.js"></script>
    </body>
</html>
